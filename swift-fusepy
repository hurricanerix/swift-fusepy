#!/usr/bin/env python
# -*- coding: iso-8859-15 -*-
# The MIT License (MIT)
#
# Copyright (c) 2014 Richard Hawkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import errno
import getpass
import os
import pyrax
import requests

from calendar import timegm
from datetime import datetime
from fuse import FUSE, FuseOSError, Operations
from pwd import getpwnam

FUSE_MODES = {
    'IFREG': 0100000,
    'IFDIR': 0040000,
    'IRWXU': 00700,
    'IRUSR': 00400,
    'IWUSR': 00200,
    'IXUSR': 00100,
    'IRWXG': 00070,
    'IRGRP': 00040,
    'IWGRP': 00020,
    'IXGRP': 00010,
    'IRWXO': 00007,
    'IROTH': 00004,
    'IWOTH': 00002,
    'IXOTH': 00001}

__version__ = '0.0.1'


class SwiftFusePy(Operations):
    """
    FUSE file system to mount a Swift container.
    """

    def __init__(self, identity_type, credentials_file, container_name,
                 username=None):
        """
        @param identity_type: type of identity to use.
        @type identity_type: string
        @param credentials_file: absolute path to the file containing the
                                 credentials required to auth with swift.
        @type credentials_file: string
        @param container_name: name of the container to be mounted.
        @type container_name: string
        """
        self.identity_type = identity_type
        self.credentials_file = credentials_file
        self.container_name = container_name
        self.container = None
        self._swiftfs = None

        if not username:
            username = getpass.getuser()
        self.uid = getpwnam(username).pw_uid
        self.gid = getpwnam(username).pw_gid

    def _get_container(self, reauth=False):
        """
        Get the container to be mounted.

        @param reauth: if True, re-authenticate, otherwise returned the
                       previously retrieved container object.
        @type reauth: boolean
        """
        if not self.container or reauth:
            pyrax.set_setting("identity_type", self.identity_type)
            pyrax.set_setting('custom_user_agent',
                              'Swift-FusePy/{0}'.format(__version__))
            pyrax.set_credential_file(self.credentials_file)
            self.container = pyrax.cloudfiles.get_container(
                self.container_name)
        return self.container

    def _set_swiftfs_stats(self, objects):
        """
        Build the swiftfs from objcects retunred from pyrax.

        @param objects: list of objects
        @type: object
        """
        def insert_obj(name, obj, swiftfs):
            if '/' in name:
                (dir_name, dir_cont) = name.split('/', 1)
                if dir_name not in swiftfs['contents']:
                    swiftfs['contents'][dir_name] = {
                        'st_uid': self.uid,
                        'st_gid': self.gid,
                        'st_mode': self._get_mode(directory=True, ugo='rx'),
                        'contents': {}}
                swiftfs = swiftfs['contents'][dir_name]
                insert_obj(dir_cont, obj, swiftfs)
            else:
                swiftfs['contents'][name] = {
                    'st_uid': self.uid,
                    'st_gid': self.gid,
                    'st_mode': self._get_mode(user='r', group='r'),
                    'st_mtime': self._get_timestamp(obj.last_modified),
                    'st_size': obj.total_bytes}
        self._swiftfs = {
            '/': {
                'st_uid': self.uid,
                'st_gid': self.gid,
                'st_mode': self._get_mode(directory=True, ugo='rx'),
                'contents': {}}}
        for obj in objects:
            insert_obj(obj.name, obj, swiftfs=self._swiftfs['/'])

    def _is_dir(self, stats):
        """
        Tests if the stats dictionary represents a directory.
        """
        if not stats:
            return False
        return (stats.get('st_mode', 0) & FUSE_MODES.get('IFDIR') ==
                FUSE_MODES.get('IFDIR'))

    def _get_swiftfs(self, path='', refresh=False):
        """
        Get the swift file system.

        @param refresh: If False, return a cached copy if possible, otherwise
                        make a call to cloud files for the objects.
        @type refresh: boolean

        @return: representation of swift objects.
        @rtype: dict
        """
        def get_dir(path, swiftfs):
            if path == '/':
                return swiftfs['/']
            if '/' in swiftfs:
                path = path.lstrip('/')
                return get_dir(path, swiftfs['/']['contents'])

            if '/' in path:
                (name, dir_cont) = path.split('/', 1)
                return get_dir(dir_cont, swiftfs[name]['contents'])

            tmp = swiftfs.get(path)
            return tmp

        if self._swiftfs and not refresh:
            return get_dir(path, self._swiftfs)

        container = self._get_container()
        objects = container.get_objects()

        self._set_swiftfs_stats(objects)

        return get_dir(path, self._swiftfs)

    def _get_timestamp(self, date_string):
        """
        Convert a date string to a unix timestamp.

        @param date_string: date to be converted
        @type date_string: string

        @return: unix timestamp
        @rtype: int
        """
        utc = datetime.strptime(date_string, '%Y-%m-%dT%H:%M:%S')
        return timegm(utc.utctimetuple())

    def _get_mode(self, directory=False, ugo='', user='', group='', other=''):
        """
        Returns a mode based on inputs provided.

        @param directory: If True sets flag indicating a directory, otherwise
                          sets the flag indicating a regular file.
        @type directory: boolean
        @param ugo: applies permissions to all (user, group, other).
                    acceptable values are:
                        'r' for read access
                        'w' for write access
                        'x' for execute access
        @type ugo: string
        @param user: applies permissions to user, same available values as ugo.
        @type user: string
        @param group: applies permissions to group, same available values as
                      ugo.
        @type group: string
        @param other: applies permissions to other, same available values as
                      ugo.
        @type other: string

        @return: mode
        @rtype: int
        """
        mode = 0

        if directory:
            mode = FUSE_MODES.get('IFDIR')
        else:
            mode = FUSE_MODES.get('IFREG')

        if 'r' in user or 'r' in ugo:
            mode = mode | FUSE_MODES.get('IRUSR')
        if 'r' in group or 'r' in ugo:
            mode = mode | FUSE_MODES.get('IRGRP')
        if 'r' in other or 'r' in ugo:
            mode = mode | FUSE_MODES.get('IROTH')

        if 'w' in user or 'w' in ugo:
            mode = mode | FUSE_MODES.get('IWUSR')
        if 'w' in group or 'w' in ugo:
            mode = mode | FUSE_MODES.get('IWGRP')
        if 'w' in other or 'w' in ugo:
            mode = mode | FUSE_MODES.get('IWOTH')

        if 'x' in user or 'x' in ugo:
            mode = mode | FUSE_MODES.get('IXUSR')
        if 'x' in group or 'x' in ugo:
            mode = mode | FUSE_MODES.get('IXGRP')
        if 'x' in other or 'x' in ugo:
            mode = mode | FUSE_MODES.get('IXOTH')

        return mode

    def getattr(self, path, fh=None):
        """
        Return stat structure for the path provided.

        U{stat info<http://man7.org/linux/man-pages/man2/stat.2.html>}

        @param path: path to the resource to return stats for
        @type path: string
        @param fh: file handle
        @type fh:

        @return: stats
        @type: dict
        """
        stats = self._get_swiftfs(path)

        if stats is None:
            raise FuseOSError(errno.ENOENT)

        return {
            'st_mtime': stats.get('st_mtime', 0),
            'st_uid': stats.get('st_uid', 0),
            'st_gid': stats.get('st_gid', 0),
            'st_mode': stats.get('st_mode', 0),
            'st_size': stats.get('st_size', 0)}

    def readdir(self, path, fh):
        """
        Get a list of the contents of a directory.

        @param path: path to the directory to return contents of.
        @type path: string
        @param fh: file handle
        @type fh:

        @return: directories/files
        @type: list
        """
        swiftfs = self._get_swiftfs(path)
        swiftfs = swiftfs['contents']

        contents = ['.', '..']
        for name in swiftfs.iterkeys():
            contents.append(name)
        return contents

    def read(self, path, length, offset, fh):
        # Some hackery here due to pyrax not letting me (as far as I can tell)
        # make range requests to the object.
        token = pyrax.identity.token
        endpoint = pyrax.cloudfiles.connection.url
        path = path.lstrip('/')
        url = '{0}/{1}/{2}'.format(endpoint, self.container_name, path)

        headers = {'x-auth-token': token,
                   'Range': 'bytes={0}-{1}'.format(
                       offset, offset + length - 1)}
        response = requests.get(url, headers=headers)

        if not response.ok:
            raise FuseOSError(errno.EREMOTEIO)

        return response.content


def main():
    parser = argparse.ArgumentParser(
        description='Mount a Swift container to your local file system')
    parser.add_argument('--credentials_file', default='~/.swift.creds',
                        help='credentials file for connecting to Swift')
    parser.add_argument('--fsname', default=None, help='file system name')
    parser.add_argument('--identity_type', default='rackspace',
                        help='should be either \'rackspace\' or \'keystone\'')
    parser.add_argument('container_name', help='container to mount')
    parser.add_argument('mount_point',
                        help='directory to mount the container to')

    args = parser.parse_args()
    args.credentials_file = os.path.expanduser(args.credentials_file)

    if not args.fsname:
        args.fsname = 'swift.{0}'.format(args.container_name)

    FUSE(SwiftFusePy(args.identity_type, args.credentials_file,
                     args.container_name),
         args.mount_point, foreground=True, fsname=args.fsname)


if __name__ == '__main__':
    main()
